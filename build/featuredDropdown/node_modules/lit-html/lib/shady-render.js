import{insertNodeIntoTemplate,removeNodesFromTemplate}from"./modify-template.js";import{parts,render as litRender}from"./render.js";import{templateCaches}from"./template-factory.js";import{TemplateResult}from"./template-result.js";import{Template}from"./template.js";export{html,svg,TemplateResult}from"../lit-html.js";const getTemplateCacheKey=(type,scopeName)=>`${type}--${scopeName}`;let compatibleShadyCSSVersion=!0;if("undefined"===typeof window.ShadyCSS){compatibleShadyCSSVersion=!1}else if("undefined"===typeof window.ShadyCSS.prepareTemplateDom){console.warn(`Incompatible ShadyCSS version detected.`+`Please update to at least @webcomponents/webcomponentsjs@2.0.2 and`+`@webcomponents/shadycss@1.3.1.`);compatibleShadyCSSVersion=!1}const shadyTemplateFactory=scopeName=>result=>{const cacheKey=getTemplateCacheKey(result.type,scopeName);let templateCache=templateCaches.get(cacheKey);if(templateCache===void 0){templateCache=new Map;templateCaches.set(cacheKey,templateCache)}let template=templateCache.get(result.strings);if(template===void 0){const element=result.getTemplateElement();if(compatibleShadyCSSVersion){window.ShadyCSS.prepareTemplateDom(element,scopeName)}template=new Template(result,element);templateCache.set(result.strings,template)}return template},TEMPLATE_TYPES=["html","svg"],removeStylesFromLitTemplates=scopeName=>{TEMPLATE_TYPES.forEach(type=>{const templates=templateCaches.get(getTemplateCacheKey(type,scopeName));if(templates!==void 0){templates.forEach(template=>{const{element:{content}}=template,styles=new Set;Array.from(content.querySelectorAll("style")).forEach(s=>{styles.add(s)});removeNodesFromTemplate(template,styles)})}})},shadyRenderSet=new Set,prepareTemplateStyles=(renderedDOM,template,scopeName)=>{shadyRenderSet.add(scopeName);const styles=renderedDOM.querySelectorAll("style");if(0===styles.length){return}const condensedStyle=document.createElement("style");for(let i=0;i<styles.length;i++){const style=styles[i];style.parentNode.removeChild(style);condensedStyle.textContent+=style.textContent}removeStylesFromLitTemplates(scopeName);insertNodeIntoTemplate(template,condensedStyle,template.element.content.firstChild);window.ShadyCSS.prepareTemplateStyles(template.element,scopeName);if(window.ShadyCSS.nativeShadow){const style=template.element.content.querySelector("style");renderedDOM.insertBefore(style.cloneNode(!0),renderedDOM.firstChild)}else{template.element.content.insertBefore(condensedStyle,template.element.content.firstChild);const removes=new Set([condensedStyle]);removeNodesFromTemplate(template,removes)}};export const render=(result,container,options)=>{const scopeName=options.scopeName,hasRendered=parts.has(container);litRender(result,container,Object.assign({templateFactory:shadyTemplateFactory(scopeName)},options));if(container instanceof ShadowRoot&&compatibleShadyCSSVersion&&result instanceof TemplateResult){if(!shadyRenderSet.has(scopeName)){const part=parts.get(container),instance=part.value;prepareTemplateStyles(container,instance.template,scopeName)}if(!hasRendered){window.ShadyCSS.styleElement(container.host)}}};